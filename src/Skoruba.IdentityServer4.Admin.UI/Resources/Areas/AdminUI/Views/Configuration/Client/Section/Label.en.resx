<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AbsoluteRefreshTokenLifetime_Info" xml:space="preserve">
    <value>Maximum lifetime of a refresh token in seconds. Defaults to 2592000 seconds / 30 days</value>
  </data>
  <data name="AbsoluteRefreshTokenLifetime_Label" xml:space="preserve">
    <value>Absolute Refresh Token Lifetime</value>
  </data>
  <data name="AccessTokenLifetime_Info" xml:space="preserve">
    <value>Lifetime of access token in seconds (defaults to 3600 seconds / 1 hour)</value>
  </data>
  <data name="AccessTokenLifetime_Label" xml:space="preserve">
    <value>Access Token Lifetime</value>
  </data>
  <data name="AccessTokenTypes_Info" xml:space="preserve">
    <value>Specifies whether the access token is a reference token or a self contained JWT token (defaults to Jwt).</value>
  </data>
  <data name="AccessTokenTypes_Label" xml:space="preserve">
    <value>Access Token Type</value>
  </data>
  <data name="AllowAccessTokensViaBrowser_Info" xml:space="preserve">
    <value>Specifies whether this client is allowed to receive access tokens via the browser. This is useful to harden flows that allow multiple response types (e.g. by disallowing a hybrid flow client that is supposed to use code id_token to add the token response type and thus leaking the token to the browser.</value>
  </data>
  <data name="AllowAccessTokensViaBrowser_Label" xml:space="preserve">
    <value>Allow Access Token Via Browser</value>
  </data>
  <data name="AllowOfflineAccess_Info" xml:space="preserve">
    <value>Specifies whether this client can request refresh tokens (be requesting the offline_access scope)</value>
  </data>
  <data name="AllowOfflineAccess_Label" xml:space="preserve">
    <value>Allow Offline Access</value>
  </data>
  <data name="AllowPlainTextPkce_Info" xml:space="preserve">
    <value>Specifies whether clients using PKCE can use a plain text code challenge (not recommended - and default to false)</value>
  </data>
  <data name="AllowPlainTextPkce_Label" xml:space="preserve">
    <value>Allow Plain Text Pkce</value>
  </data>
  <data name="AllowRememberConsent_Info" xml:space="preserve">
    <value>Specifies whether user can choose to store consent decisions. Defaults to true.</value>
  </data>
  <data name="AllowRememberConsent_Label" xml:space="preserve">
    <value>Allow Remember Consent</value>
  </data>
  <data name="AlwaysIncludeUserClaimsInIdToken_Info" xml:space="preserve">
    <value />
  </data>
  <data name="AlwaysIncludeUserClaimsInIdToken_Label" xml:space="preserve">
    <value>Always Include User Claims In IdToken</value>
  </data>
  <data name="AlwaysSendClientClaims_Info" xml:space="preserve">
    <value>If set, the client claims will be sent for every flow. If not, only for client credentials flow (default is false)</value>
  </data>
  <data name="AlwaysSendClientClaims_Label" xml:space="preserve">
    <value>Always Send Client Claims</value>
  </data>
  <data name="AuthorizationCodeLifetime_Info" xml:space="preserve">
    <value>Lifetime of authorization code in seconds (defaults to 300 seconds / 5 minutes)</value>
  </data>
  <data name="AuthorizationCodeLifetime_Label" xml:space="preserve">
    <value>Authorization Code Lifetime</value>
  </data>
  <data name="ClientId_Info" xml:space="preserve">
    <value>Unique ID of the client</value>
  </data>
  <data name="ClientId_Label" xml:space="preserve">
    <value>ClientId</value>
  </data>
  <data name="ClientName_Info" xml:space="preserve">
    <value>Client display name (used for logging and consent screen)</value>
  </data>
  <data name="ClientName_Label" xml:space="preserve">
    <value>Client Name</value>
  </data>
  <data name="ClientUri_Info" xml:space="preserve">
    <value>URI to further information about client (used on consent screen)</value>
  </data>
  <data name="ClientUri_Label" xml:space="preserve">
    <value>Client Uri</value>
  </data>
  <data name="Enabled_Info" xml:space="preserve">
    <value>Specifies if client is enabled. Defaults to true.</value>
  </data>
  <data name="Enabled_Label" xml:space="preserve">
    <value>Enabled</value>
  </data>
  <data name="EnableLocalLogin_Info" xml:space="preserve">
    <value>Specifies if this client can use local accounts, or external IdPs only. Defaults to true.</value>
  </data>
  <data name="EnableLocalLogin_Label" xml:space="preserve">
    <value>Enable Local Login</value>
  </data>
  <data name="IdentityTokenLifetime_Info" xml:space="preserve">
    <value>Lifetime to identity token in seconds (defaults to 300 seconds / 5 minutes)</value>
  </data>
  <data name="IdentityTokenLifetime_Label" xml:space="preserve">
    <value>Identity Token Lifetime</value>
  </data>
  <data name="IncludeJwtId_Info" xml:space="preserve">
    <value>Specifies whether JWT access tokens should have an embedded unique ID (via the jti claim).</value>
  </data>
  <data name="IncludeJwtId_Label" xml:space="preserve">
    <value>Include Jwt Id</value>
  </data>
  <data name="LogoUri_Info" xml:space="preserve">
    <value>URI to client logo (used on consent screen)</value>
  </data>
  <data name="LogoUri_Label" xml:space="preserve">
    <value>Logo Uri</value>
  </data>
  <data name="RefreshTokenExpiration_Info" xml:space="preserve">
    <value>Absolute the refresh token will expire on a fixed point in time (specified by the AbsoluteRefreshTokenLifetime)

Sliding when refreshing the token, the lifetime of the refresh token will be renewed (by the amount specified in SlidingRefreshTokenLifetime). The lifetime will not exceed AbsoluteRefreshTokenLifetime.</value>
  </data>
  <data name="RefreshTokenExpiration_Label" xml:space="preserve">
    <value>Refresh Token Expiration</value>
  </data>
  <data name="RefreshTokenUsage.Info" xml:space="preserve">
    <value>ReUse the refresh token handle will stay the same when refreshing tokens

OneTime the refresh token handle will be updated when refreshing tokens</value>
  </data>
  <data name="RefreshTokenUsage.Label" xml:space="preserve">
    <value>Refresh Token Usage</value>
  </data>
  <data name="RefreshTokenUsage_Info" xml:space="preserve">
    <value>ReUse the refresh token handle will stay the same when refreshing tokens

OneTime the refresh token handle will be updated when refreshing tokens</value>
  </data>
  <data name="RefreshTokenUsage_Label" xml:space="preserve">
    <value>Refresh Token Usage</value>
  </data>
  <data name="RequireClientSecret_Info" xml:space="preserve">
    <value>Specifies whether this client needs a secret to request tokens from the token endpoint (defaults to true)</value>
  </data>
  <data name="RequireClientSecret_Label" xml:space="preserve">
    <value>Require Client Secret</value>
  </data>
  <data name="RequireConsent_Info" xml:space="preserve">
    <value>Specifies whether a consent screen is required. Defaults to true.</value>
  </data>
  <data name="RequireConsent_Label" xml:space="preserve">
    <value>Require Consent</value>
  </data>
  <data name="RequirePkce_Info" xml:space="preserve">
    <value>Specifies whether clients using an authorization code based grant type must send a proof key</value>
  </data>
  <data name="RequirePkce_Label" xml:space="preserve">
    <value>Require Pkce</value>
  </data>
  <data name="SlidingRefreshTokenLifetime_Info" xml:space="preserve">
    <value>Sliding lifetime of a refresh token in seconds. Defaults to 1296000 seconds / 15 days</value>
  </data>
  <data name="SlidingRefreshTokenLifetime_Label" xml:space="preserve">
    <value>Sliding Refresh Token Lifetime</value>
  </data>
  <data name="UpdateAccessTokenClaimsOnRefresh_Info" xml:space="preserve">
    <value>Gets or sets a value indicating whether the access token (and its claims) should be updated on a refresh token request.</value>
  </data>
  <data name="UpdateAccessTokenClaimsOnRefresh_Label" xml:space="preserve">
    <value>Update Access Token Claims On Refresh</value>
  </data>
  <data name="AllowedCorsOrigins_Info" xml:space="preserve">
    <value>If specified, will be used by the default CORS policy service implementations (In-Memory and EF) to build a CORS policy for JavaScript clients.</value>
  </data>
  <data name="AllowedCorsOrigins_Label" xml:space="preserve">
    <value>Allowed Cors Origins</value>
  </data>
  <data name="AllowedGrantTypes_Info" xml:space="preserve">
    <value>Specifies the grant types the client is allowed to use. Use the GrantTypes class for common combinations. List of default grants: Implicit Grant - (implicit), Client Credentials Grant - (client_credentials), Authorization Code Grant - (authorization_code), Hybrid grant - (hybrid), Resource Owner Password Credentials Grant - (password)</value>
  </data>
  <data name="AllowedGrantTypes_Label" xml:space="preserve">
    <value>Allowed Grant Types</value>
  </data>
  <data name="AllowedScopes_Info" xml:space="preserve">
    <value>By default a client has no access to any resources - specify the allowed resources by adding the corresponding scopes names</value>
  </data>
  <data name="AllowedScopes_Label" xml:space="preserve">
    <value>Allowed Scopes</value>
  </data>
  <data name="Claims_Info" xml:space="preserve">
    <value>Allows settings claims for the client (will be included in the access token).</value>
  </data>
  <data name="Claims_Label" xml:space="preserve">
    <value>Claims</value>
  </data>
  <data name="ClientSecrets_Info" xml:space="preserve">
    <value>List of client secrets - credentials to access the token endpoint.</value>
  </data>
  <data name="ClientSecrets_Label" xml:space="preserve">
    <value>Client Secrets</value>
  </data>
  <data name="IdentityProviderRestrictions_Info" xml:space="preserve">
    <value>Specifies which external IdPs can be used with this client (if list is empty all IdPs are allowed). Defaults to empty.</value>
  </data>
  <data name="IdentityProviderRestrictions_Label" xml:space="preserve">
    <value>Identity Provider Restrictions</value>
  </data>
  <data name="PostLogoutRedirectUris_Info" xml:space="preserve">
    <value>Specifies allowed URIs to redirect to after logout</value>
  </data>
  <data name="PostLogoutRedirectUris_Label" xml:space="preserve">
    <value>Post Logout Redirect Uris</value>
  </data>
  <data name="RedirectUris_Info" xml:space="preserve">
    <value>Specifies the allowed URIs to return tokens or authorization codes to</value>
  </data>
  <data name="RedirectUris_Label" xml:space="preserve">
    <value>Redirect Uris</value>
  </data>
  <data name="Type_Info" xml:space="preserve">
    <value />
  </data>
  <data name="Type_Label" xml:space="preserve">
    <value>Claim Type</value>
  </data>
  <data name="Value_Info" xml:space="preserve">
    <value />
  </data>
  <data name="Value_Label" xml:space="preserve">
    <value>Claim Value</value>
  </data>
  <data name="SecretType_Info" xml:space="preserve">
    <value />
  </data>
  <data name="SecretType_Label" xml:space="preserve">
    <value>Secret Type</value>
  </data>
  <data name="SecretValue_Info" xml:space="preserve">
    <value />
  </data>
  <data name="SecretValue_Label" xml:space="preserve">
    <value>Secret Value</value>
  </data>
  <data name="HashType_Info" xml:space="preserve">
    <value />
  </data>
  <data name="HashType_Label" xml:space="preserve">
    <value>Hash Type</value>
  </data>
  <data name="RoleNormalizedName_Info" xml:space="preserve">
    <value>The Normalized Role Name</value>
  </data>
  <data name="RoleNormalizedName_Label" xml:space="preserve">
    <value>Normalized Name</value>
  </data>
  <data name="BackChannelLogoutSessionRequired_Info" xml:space="preserve">
    <value>Specifies if the user’s session id should be sent in the request to the BackChannelLogoutUri. Defaults to true.</value>
  </data>
  <data name="BackChannelLogoutSessionRequired_Label" xml:space="preserve">
    <value>Back Channel Logout Session Required</value>
  </data>
  <data name="BackChannelLogoutUri_Info" xml:space="preserve">
    <value>Specifies logout URI at client for HTTP based back-channel logout. See the OIDC Back-Channel spec for more details.</value>
  </data>
  <data name="BackChannelLogoutUri_Label" xml:space="preserve">
    <value>Back Channel Logout Uri</value>
  </data>
  <data name="ClientClaimsPrefix_Info" xml:space="preserve">
    <value>If set, the prefix client claim types will be prefixed with. Defaults to client_. The intent is to make sure they don’t accidentally collide with user claims.</value>
  </data>
  <data name="ClientClaimsPrefix_Label" xml:space="preserve">
    <value>Client Claims Prefix</value>
  </data>
  <data name="Description_Info" xml:space="preserve">
    <value>Client Description</value>
  </data>
  <data name="Description_Label" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="FrontChannelLogoutSessionRequired_Info" xml:space="preserve">
    <value>Specifies if the user’s session id should be sent to the FrontChannelLogoutUri. Defaults to true.</value>
  </data>
  <data name="FrontChannelLogoutSessionRequired_Label" xml:space="preserve">
    <value>Front Channel Logout Session Required</value>
  </data>
  <data name="FrontChannelLogoutUri_Info" xml:space="preserve">
    <value>Specifies logout URI at client for HTTP based front-channel logout. See the OIDC Front-Channel spec for more details.</value>
  </data>
  <data name="FrontChannelLogoutUri_Label" xml:space="preserve">
    <value>Front Channel Logout Uri</value>
  </data>
  <data name="PairWiseSubjectSalt_Info" xml:space="preserve">
    <value>Salt value used in pair-wise subjectId generation for users of this client.</value>
  </data>
  <data name="PairWiseSubjectSalt_Label" xml:space="preserve">
    <value>Pair Wise Subject Salt</value>
  </data>
  <data name="Properties_Info" xml:space="preserve">
    <value>Dictionary to hold any custom client-specific values as needed.</value>
  </data>
  <data name="Properties_Label" xml:space="preserve">
    <value>Properties</value>
  </data>
  <data name="PropertyKey_Info" xml:space="preserve">
    <value>Key</value>
  </data>
  <data name="PropertyKey_Label" xml:space="preserve">
    <value>Key</value>
  </data>
  <data name="PropertyValue_Info" xml:space="preserve">
    <value>Value</value>
  </data>
  <data name="PropertyValue_Label" xml:space="preserve">
    <value>Value</value>
  </data>
  <data name="ProtocolType_Info" xml:space="preserve">
    <value>Default is OpenID Connect protocol</value>
  </data>
  <data name="ProtocolType_Label" xml:space="preserve">
    <value>Protocol Type</value>
  </data>
  <data name="UserSsoLifetime_Info" xml:space="preserve">
    <value>The maximum duration (in seconds) since the last time the user authenticated. Defaults to null</value>
  </data>
  <data name="UserSsoLifetime_Label" xml:space="preserve">
    <value>User Sso Lifetime</value>
  </data>
  <data name="DeviceCodeLifetime_Info" xml:space="preserve">
    <value>Lifetime to device code in seconds (defaults to 300 seconds / 5 minutes)</value>
  </data>
  <data name="DeviceCodeLifetime_Label" xml:space="preserve">
    <value>Device Code Lifetime</value>
  </data>
  <data name="UserCodeType_Info" xml:space="preserve">
    <value>Specifies the type of user code to use for the client. Otherwise falls back to default.</value>
  </data>
  <data name="UserCodeType_Label" xml:space="preserve">
    <value>User Code Type</value>
  </data>
  <data name="Expiration_Info" xml:space="preserve">
    <value>Expiration</value>
  </data>
  <data name="Expiration_Label" xml:space="preserve">
    <value>Expiration</value>
  </data>
  <data name="SecretDescription_Info" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="SecretDescription_Label" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="RequireRequestObject_Label" xml:space="preserve">
    <value>Require Request Object</value>
  </data>
  <data name="RequireRequestObject_Info" xml:space="preserve">
    <value>Specifies whether this client needs to wrap the authorize request parameters in a JWT (defaults to false)</value>
  </data>
  <data name="SigningAlgorithms_Label" xml:space="preserve">
    <value>Allowed Identity Token Signing Algorithms</value>
  </data>
  <data name="SigningAlgorithms_Info" xml:space="preserve">
    <value>List of allowed signing algorithms for identity token. If empty, will use the server default signing algorithm.</value>
  </data>
</root>